iOS处理认证挑战
在 iOS 开发中，网络请求可能会遇到各种认证挑战（如 HTTPS 证书验证、HTTP Basic Auth、代理认证等）。本文将详细介绍如何通过 URLSession 处理这些挑战，以及最佳实践。

一、认证挑战的类型与触发场景
iOS 中的认证挑战主要分为以下几类：
HTTPS 证书挑战
触发条件：服务器证书校验失败（如证书过期、域名不匹配、自签名证书）。
挑战方法：NSURLAuthenticationMethodServerTrust。
HTTP 基本 / 摘要认证
触发条件：服务器返回 401 Unauthorized 状态码，并包含 WWW-Authenticate 头。
挑战方法：NSURLAuthenticationMethodHTTPBasic 或 NSURLAuthenticationMethodHTTPDigest。
代理服务器认证
触发条件：通过需要认证的代理服务器访问资源。
挑战方法：NSURLAuthenticationMethodProxyBasic 或 NSURLAuthenticationMethodProxyDigest。


二、核心处理机制：URLSessionDelegate
通过实现 URLSessionDelegate 或 URLSessionTaskDelegate 的以下方法处理挑战：

func urlSession(_ session: URLSession, 
                didReceive challenge: URLAuthenticationChallenge, 
                completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    
    // 根据挑战类型执行不同处理逻辑
    switch challenge.protectionSpace.authenticationMethod {
    case NSURLAuthenticationMethodServerTrust:
        handleServerTrustChallenge(challenge, completionHandler: completionHandler)
    case NSURLAuthenticationMethodHTTPBasic:
        handleHTTPBasicChallenge(challenge, completionHandler: completionHandler)
    case NSURLAuthenticationMethodProxyBasic:
        handleProxyChallenge(challenge, completionHandler: completionHandler)
    default:
        // 使用默认处理
        completionHandler(.performDefaultHandling, nil)
    }
}

三、HTTPS 证书挑战处理
1. 默认验证逻辑
private func handleServerTrustChallenge(_ challenge: URLAuthenticationChallenge, 
                                       completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    
    guard let trust = challenge.protectionSpace.serverTrust else {
        completionHandler(.cancelAuthenticationChallenge, nil)
        return
    }
    
    // 创建 SSL 验证策略（验证域名）
    let policy = SecPolicyCreateSSL(true, challenge.protectionSpace.host as CFString)
    SecTrustSetPolicies(trust, policy)
    
    // 评估证书信任
    var result: SecTrustResultType = .invalid
    SecTrustEvaluateWithError(trust, nil)
    SecTrustGetTrustResult(trust, &result)
    
    switch result {
    case .proceed, .unspecified:
        // 系统信任该证书
        let credential = URLCredential(trust: trust)
        completionHandler(.useCredential, credential)
    default:
        // 系统不信任，尝试自定义验证（如证书固定）
        let isValid = performCustomTrustValidation(trust, forHost: challenge.protectionSpace.host)
        completionHandler(isValid ? .useCredential : .cancelAuthenticationChallenge, nil)
    }
}

2. 证书固定（Certificate Pinning）实现
private func performCustomTrustValidation(_ trust: SecTrust, forHost host: String) -> Bool {
    // 1. 验证域名
    let policy = SecPolicyCreateSSL(true, host as CFString)
    SecTrustSetPolicies(trust, policy)
    
    // 2. 获取服务器证书链
    let certCount = SecTrustGetCertificateCount(trust)
    guard certCount > 0, let serverCert = SecTrustGetCertificateAtIndex(trust, 0) else {
        return false
    }
    
    // 3. 计算证书公钥哈希
    let publicKey = SecCertificateCopyKey(serverCert)!
    let keyData = SecKeyCopyExternalRepresentation(publicKey, nil) as Data?
    let keyHash = keyData?.sha256Hash() // 自定义哈希计算方法
    
    // 4. 与预存的公钥哈希比较
    return keyHash == preloadedPublicKeyHash
}

四、HTTP Basic Auth 挑战处理
private func handleHTTPBasicChallenge(_ challenge: URLAuthenticationChallenge, 
                                     completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    
    // 检查是否已尝试过认证
    if challenge.previousFailureCount > 0 {
        completionHandler(.cancelAuthenticationChallenge, nil)
        return
    }
    
    // 获取用户名和密码（实际项目中应从安全存储获取）
    let username = "your_username"
    let password = "your_password"
    
    // 创建凭证
    let credential = URLCredential(user: username, password: password, persistence: .forSession)
    
    // 使用凭证继续请求
    completionHandler(.useCredential, credential)
}

五、代理服务器认证处理
private func handleProxyChallenge(_ challenge: URLAuthenticationChallenge, 
                                 completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
    
    // 检查代理配置
    guard let proxyHost = challenge.protectionSpace.host,
          let proxyPort = challenge.protectionSpace.port,
          let user = proxyCredentials[proxyHost]?.username,
          let password = proxyCredentials[proxyHost]?.password else {
        completionHandler(.cancelAuthenticationChallenge, nil)
        return
    }
    
    // 创建代理凭证
    let credential = URLCredential(user: user, password: password, persistence: .forSession)
    completionHandler(.useCredential, credential)
}

六、高级技巧：全局认证管理器
class AuthenticationManager: NSObject, URLSessionDelegate {
    static let shared = AuthenticationManager()
    
    private override init() {
        super.init()
    }
    
    func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        // 根据挑战类型分发处理
        switch challenge.protectionSpace.authenticationMethod {
        case NSURLAuthenticationMethodServerTrust:
            handleServerTrustChallenge(challenge, completionHandler: completionHandler)
        case NSURLAuthenticationMethodHTTPBasic:
            handleHTTPBasicChallenge(challenge, completionHandler: completionHandler)
        default:
            completionHandler(.performDefaultHandling, nil)
        }
    }
    
    // 其他处理方法...
}
使用方式：
let config = URLSessionConfiguration.default
let session = URLSession(configuration: config, delegate: AuthenticationManager.shared, delegateQueue: nil)
